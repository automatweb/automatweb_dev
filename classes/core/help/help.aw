<?php
// $Header: /home/cvs/automatweb_dev/classes/core/help/help.aw,v 1.3 2005/12/20 13:20:08 ahti Exp $

// more ideas --- I might want to keep the help open when switching between tabs... for this I need to 
// set a cookie

class help extends aw_template
{
	function help()
	{
		$this->tpl_init("help");
	}

	/** shows a help browser for a class
		@attrib name=browser default="1"
		@param clid required type=int
	**/
	function browser($arr)
	{
		$this->read_template("browser.tpl");

		$cfgu = get_instance("cfg/cfgutils");
		if (!$cfgu->has_properties(array("clid" => $arr["clid"])))
		{
			die(t("Selle klassil puudub abiinfo"));
		};

		$atc_inst = get_instance("admin/add_tree_conf");
		$atc_id = $atc_inst->get_current_conf();

		$props = $cfgu->load_properties(array(
			"clid" => $arr["clid"],
		));

		$clinf = aw_ini_get("classes");
		$classdat = $clinf[$arr["clid"]];

		/*
		$am = get_instance("admin/admin_menus");
		$am->get_add_menu(array(
			"parent" => aw_ini_get("rootmenu"),
			"ret_data" => true,
		));
		*/


		$atc = get_instance("admin/add_tree_conf");
		$tree = $atc->get_class_tree();



		$class_tree = $tree;

		$groups = $cfgu->get_groupinfo();

		$tree = get_instance("vcl/treeview");
		$tree->start_tree (array (
			"type" => TREE_DHTML,
			"url_target" => "helpcontent",
			"get_branch_func" => $this->mk_my_orb("get_node",array("parent" => " ")),
			"has_root" => 1,
			//"tree_id" => "resourcetree",
			//"persist_state" => 1,
                ));

		classload("core/icons");

		$tree->add_item(0,array(
			"name" => "Klassid",
			"id" => "root",
			"url" => $this->mk_my_orb("browser",array("clid" => $arr["clid"])),
			"is_open" => 1,
			"iconurl" => icons::get_icon_url($arr["clid"]),
			"url_target" => "",
		));

		// the class_tree that has been generated by admin_menu does not contain enough information 
		// for me
		$tcnt = 0;

		foreach($class_tree as $item_id => $item_collection)
		{
			foreach($item_collection as $el_id => $el_data)
			{
				/*
				if ($el_data["separator"])
				{
					continue;
				};
				*/

				/*
				print "<pre>";
				print_r($el_data);
				print "</pre>";
				flush();
				*/

				$parnt = is_numeric($item_id) && $item_id == 0 ? "root" : $item_id;
				$tcnt++;
				$tree->add_item($parnt,array(
					"name" => $el_data["name"],
					"id" => $el_data["id"],
					"url" => "#",
					"is_open" => 0,
					"iconurl" => empty($el_data["clid"]) ? "" : icons::get_icon_url($el_data["clid"]),
				));

				if ($el_data["clid"])
				{
					$tree->add_item($el_data["id"],array(
						"name" => "fafa",
						"id" => $el_data["id"] + 10000,
					));
				}
				else
				{
					$tree->add_item($el_data["id"],array(
						"name" => "fafa",
						"id" => $el_data["id"] + 10000,
					));


				};
					
			};
		};

		// nii. kuidas ma saan selle puu nii tööle, et oksi laetakse on-demand ja samal ajal saaksid
		// mõned oksad lahti ka olla?

		// ja teisest küljest - see get_branch_func tagastab HTMLi ja mitte puustruktuuri mulle vajalikul
		// kujul. Which is NOT what I want. Fuckety fuck küll. teisest küljest jällegi, puud peavadki keerulid olema, siin pole midagi teha


		// get_branch_func peab ilmselt backwards compatiblity jaoks alles jääma
		// teen ühe uue lisa funktsiooni - get_branch() - mis siis annab ühe konkreetse
		// node sisu .. ja seda kutsutakse välja nii siis, kui on vaja teha konkreetne
		// puu .. kui ka siis, kui on vaja mõni oks on-demand laadida. Does that make sense?
		// hell yes .. it does

		// ja siis see asi et . see get_branch funktsioon peab ju kuidagi asju mälus hoidma
		// eeldusel, et kõik vajalik inff ei ole korraga saadaval. Oh fuck küll.

		// also, reading information about all groups of all classes is _really_ slow. 

		/*
		foreach($groups as $gkey => $gdata)
		{
			$parent = isset($gdata["parent"]) ? $gdata["parent"] : "root";
			$tree->add_item($parent,array(
				"name" => $gdata["caption"],
				"id" => $gkey,
				"url" => $this->mk_my_orb("grouphelp",array(
					"clid" => $arr["clid"],
					"grpid" => $gkey,
				))	, 
				"is_open" => 1,
				"iconurl" => "images/icons/help_topic.gif",
			));
		};
		*/

		$this->vars(array(
			// do not use the thing passed in from the URL
			"help_caption" => sprintf(t("Klassi '%s' abiinfo"),$classdat["name"]),
			"help_content_tree" => $tree->finalize_tree(),
			"retrieve_help_func" => $this->mk_my_orb("grouphelp",array(),"help"),
			"browser_caption" => t("AW abiinfo"),
		));
		die($this->parse());
	}

	/** 
		@attrib name=get_node all_args=1

	**/
	function get_node($arr) 
	{
		$this->read_template("browser.tpl");

		$cfgu = get_instance("cfg/cfgutils");
		/*
		if (!$cfgu->has_properties(array("clid" => $arr["clid"])))
		{
			die(t("Selle klassil puudub abiinfo"));
		};
		*/

		$atc_inst = get_instance("admin/add_tree_conf");
		$atc_id = $atc_inst->get_current_conf();


		$clinf = aw_ini_get("classes");
		$classdat = $clinf[$arr["clid"]];

		/*
		$am = get_instance("admin/admin_menus");
		$am->get_add_menu(array(
			"parent" => aw_ini_get("rootmenu"),
			"ret_data" => true,
		));
		*/


		$atc = get_instance("admin/add_tree_conf");
		$tree = $atc->get_class_tree();



		$class_tree = $tree;

		$groups = $cfgu->get_groupinfo();

		$tree = get_instance("vcl/treeview");
		$tree->start_tree (array (
			"type" => TREE_DHTML,
			"url_target" => "helpcontent",
			// vbla peaks see get_branc_func olema igal pool node juures .. oh geez.
			"get_branch_func" => $this->mk_my_orb("get_node",array("parent" => " ")),
			//"tree_id" => "resourcetree",
			//"persist_state" => 1,
                ));

		classload("core/icons");

		/*

		$tree->add_item(0,array(
			"name" => "Klassid",
			"id" => "root",
			"url" => $this->mk_my_orb("browser",array("clid" => $arr["clid"])),
			"is_open" => 1,
			"iconurl" => icons::get_icon_url($arr["clid"]),
			"url_target" => "",
		));
		*/

		// the class_tree that has been generated by admin_menu does not contain enough information 
		// for me
		$tcnt = 0;

		$parent = trim($arr["parent"]);
		$parent_folder = 0;
		if ("fld_" == substr($parent,0,4))
		{
			$parent_folder = substr($parent,4);
			//print "pf = $parent_folder<br>";
			

		};

		if (is_numeric($parent))
		{
			$props = $cfgu->load_properties(array(
				"clid" => $parent,
			));
			$groups = $cfgu->get_groupinfo();
		};

		foreach($class_tree as $item_id => $item_collection)
		{
			if (isset($parent) && $item_id != $parent)
			{
				continue;
			};

			foreach($item_collection as $el_id => $el_data)
			{
				/*
				if ($el_data["separator"])
				{
					continue;
				};
				*/

				/*
				print "<pre>";
				print_r($el_data);
				print "</pre>";
				flush();
				*/

				$parnt = is_numeric($item_id) && $item_id == 0 ? "root" : $item_id;
				$tcnt++;
				//$tree->add_item($parnt,array(
				$tree->add_item(0,array(
					"name" => $el_data["name"],
					"id" => $el_data["id"],
					"url" => "#",
					"is_open" => 0,
					"iconurl" => empty($el_data["clid"]) ? "" : icons::get_icon_url($el_data["clid"]),
				));

				if ($el_data["clid"])
				{
					$tree->add_item($el_data["id"],array(
						"name" => "fafa",
						"id" => $el_data["id"] + 10000,
					));
				}
				else
				{
					$tree->add_item($el_data["id"],array(
						"name" => "fafa",
						"id" => $el_data["id"] + 10000,
					));


				};
					
			};
		};

		// nii. kuidas ma saan selle puu nii tööle, et oksi laetakse on-demand ja samal ajal saaksid
		// mõned oksad lahti ka olla?

		// ja teisest küljest - see get_branch_func tagastab HTMLi ja mitte puustruktuuri mulle vajalikul
		// kujul. Which is NOT what I want. Fuckety fuck küll. teisest küljest jällegi, puud peavadki keerulid olema, siin pole midagi teha


		// get_branch_func peab ilmselt backwards compatiblity jaoks alles jääma
		// teen ühe uue lisa funktsiooni - get_branch() - mis siis annab ühe konkreetse
		// node sisu .. ja seda kutsutakse välja nii siis, kui on vaja teha konkreetne
		// puu .. kui ka siis, kui on vaja mõni oks on-demand laadida. Does that make sense?
		// hell yes .. it does

		// ja siis see asi et . see get_branch funktsioon peab ju kuidagi asju mälus hoidma
		// eeldusel, et kõik vajalik inff ei ole korraga saadaval. Oh fuck küll.

		// also, reading information about all groups of all classes is _really_ slow. 

		if (is_array($groups))
		{
			foreach($groups as $gkey => $gdata)
			{
				$parent = isset($gdata["parent"]) ? $gdata["parent"] : "root";
				$tree->add_item(0,array(
					"name" => $gdata["caption"],
					"id" => $gkey,
					"url" => $this->mk_my_orb("grouphelp",array(
						"clid" => $arr["clid"],
						"grpid" => $gkey,
					))	, 
					"is_open" => 1,
					"iconurl" => "images/icons/help_topic.gif",
				));
			};
		};

		die($tree->finalize_tree());

		$this->vars(array(
			// do not use the thing passed in from the URL
			"help_caption" => sprintf(t("Klassi '%s' abiinfo"),$classdat["name"]),
			"help_content_tree" => $tree->finalize_tree(),
			"retrieve_help_func" => $this->mk_my_orb("grouphelp",array(),"help"),
			"browser_caption" => t("AW abiinfo"),
		));
		die($this->parse());
		print "<pre>";
		print_r($arr);
		print "</pre>";


	}

	/** shows help for a single group
		@attrib name=grouphelp
		@param clid required type=int
		@param grpid required
	**/
	function grouphelp($arr)
	{
		$this->read_template("grouphelp.tpl");
		$this->sub_merge = 1;
		$cfgu = get_instance("cfg/cfgutils");
		if (!$cfgu->has_properties(array("clid" => $arr["clid"])))
		{
			die(t("Selle klassil puudub abiinfo"));
		};

		$props = $cfgu->load_properties(array(
			"clid" => $arr["clid"],
			"filter" => $filter,
		));
		$groups = $cfgu->get_groupinfo();

		if (empty($groups[$arr["grpid"]]))
		{
			die(t("Sellist gruppi pole"));
		};

		$prophelp = "";
		foreach($props as $pkey => $pval)
		{
			if ($pval["group"] != $arr["grpid"])
			{
				continue;
			};
			
			$this->vars(array(
				"property_name" => $pval["caption"],
				"property_comment" => $pval["comment"],
				"propery_help" => $pval["help"],
			));

			$this->parse("PROPERTY_HELP");

		};


		$this->vars(array(
			"groupname" => $groups[$arr["grpid"]]["caption"],
		));
		die($this->parse());
	}

};
?>
